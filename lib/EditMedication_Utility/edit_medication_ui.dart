// File: lib/EditMedication_Utility/edit_medication_utils.dart
import 'dart:convert';
import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:image_picker/image_picker.dart';
import 'package:intl/intl.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:http/http.dart' as http;

import '../Pages/Add_Medicaiton/Add_Dosage.dart';
import '../Pages/Add_Medicaiton/Add_Name_Picture.dart';
import '../Pages/Add_Medicaiton/Add_Start_&_End_Date.dart' show AddStartEndDatePage;
import '../Pages/EditMedication_Page.dart';

/// Shared theme constants
const Color kPrimaryColor = Color(0xFF1A5CFF);
const Color kSecondaryColor = Color(0xFF4ECDC4);
const Color kErrorColor = Color(0xFFFF6B6B);
const Color kBackgroundColor = Color(0xFFF7F9FC);
const Color kCardColor = Colors.white;
const double kBorderRadius = 16.0;
const double kSpacing = 18.0;

/// Helper utilities: time parsing, date calc, permissions, ImgBB upload.
class EditMedicationUtils {
  static TimeOfDay? parseTime(String timeStr) {
    try {
      final f = DateFormat('h:mm a', 'ar'); // changed locale here
      return TimeOfDay.fromDateTime(f.parseStrict(timeStr));
    } catch (_) {}
    return null;
  }

  static String formatTimeOfDay(TimeOfDay t) {
    final dt = DateTime(0, 0, 0, t.hour, t.minute);
    return DateFormat.jm('ar').format(dt);
  }

  static int calculateDays(DateTime start, DateTime end) => end.difference(start).inDays + 1;

  static Future<void> ensureCameraPermission() async {
    final st = await Permission.camera.request();
    if (!st.isGranted) {
      if (st.isPermanentlyDenied) openAppSettings();
      throw Exception('Camera permission denied');
    }
  }

  static Future<String> uploadToImgBB(File file, String apiKey) async {
    final b64 = base64Encode(await file.readAsBytes());
    final uri = Uri.parse('https://api.imgbb.com/1/upload?key=$apiKey');
    final resp = await http.post(uri, body: {'image': b64});
    if (resp.statusCode != 200) throw Exception('ImgBB upload failed');
    final data = json.decode(resp.body)['data'];
    return data['url'] as String;
  }
}


// File: lib/EditMedication_Utility/edit_medication_data_provider.dart


/// Provides all data-loading, state, and update logic for editing a medication.
class EditMedicationDataProvider {
  // Controllers
  final TextEditingController nameController;
  final TextEditingController dosageController;
  final PageController pageController = PageController();

  // ImgBB API key
  final String imgbbApiKey;

  // Internal state
  bool _isLoading = true;
  bool get isLoading => _isLoading;

  File? _capturedImage;
  File? get capturedImage => _capturedImage;

  String? _uploadedImageUrl;
  String? get uploadedImageUrl => _uploadedImageUrl;

  bool _isUploading = false;
  bool get isUploading => _isUploading;

  bool _hasOriginalImage = false;
  bool get hasOriginalImage => _hasOriginalImage;

  List<String> _medicineNames = [];
  List<String> get medicineNames => _medicineNames;

  String _dosageUnit = 'ملغم';
  String get dosageUnit => _dosageUnit;

  String _frequencyType = 'يومي';
  String get frequencyType => _frequencyType;

  int _frequencyNumber = 1;
  int get frequencyNumber => _frequencyNumber;

  List<TimeOfDay?> _selectedTimes = [];
  List<TimeOfDay?> get selectedTimes => _selectedTimes;

  List<bool> _isAutoGeneratedTimes = [];
  List<bool> get isAutoGeneratedTimes => _isAutoGeneratedTimes;

  Set<int> _selectedWeekdays = {};
  Set<int> get selectedWeekdays => _selectedWeekdays;

  Map<int, TimeOfDay?> _weeklyTimes = {};
  Map<int, TimeOfDay?> get weeklyTimes => _weeklyTimes;

  Map<int, bool> _weeklyAutoGenerated = {};
  Map<int, bool> get weeklyAutoGenerated => _weeklyAutoGenerated;

  DateTime? _startDate;
  DateTime? get startDate => _startDate;

  DateTime? _endDate;
  DateTime? get endDate => _endDate;

  List<int> _originalNotificationIds = [];

  EditMedicationDataProvider({
    required this.nameController,
    required this.dosageController,
    required this.imgbbApiKey,
  });

  /// Initialize by loading names and existing medication data.
  Future<void> init(String docId) async {
    _isLoading = true;
    await _loadMedicineNames();
    await loadMedicationData(docId);
    _isLoading = false;
  }

  void dispose() {
    nameController.dispose();
    dosageController.dispose();
    pageController.dispose();
  }

  Future<void> _loadMedicineNames() async {
    try {
      final raw = await rootBundle.loadString('assets/Mediciens/trade_names.json');
      final list = json.decode(raw) as List<dynamic>;
      _medicineNames = list.map((e) => e.toString()).toList();
    } catch (_) {
      _medicineNames = [];
    }
  }

  Future<void> loadMedicationData(String docId) async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) throw Exception('User not logged in');

    final doc = await FirebaseFirestore.instance
        .collection('users')
        .doc(user.uid)
        .collection('medicines')
        .doc(docId)
        .get();
    if (!doc.exists) throw Exception('Medicine not found');

    final data = doc.data()!;
    nameController.text = data['name'] ?? '';
    _parseDosage(data['dosage'] as String?);
    _frequencyType = data['frequencyType'] ?? 'يومي';
    _frequencyNumber = (data['frequencyDetails']?['timesPerDay'] as int?) ?? 1;
    _parseTimes(data['times'] as List<dynamic>?);
    _parseWeekly(data['frequencyDetails'] as Map<String, dynamic>?);

    _startDate = (data['startDate'] as Timestamp?)?.toDate();
    _endDate   = (data['endDate']   as Timestamp?)?.toDate();

    final url = data['imageUrl'] as String?;
    if (url != null && url.isNotEmpty) {
      _uploadedImageUrl = url;
      _hasOriginalImage = true;
    }

    _originalNotificationIds = List<int>.from(data['notificationIds'] ?? []);
  }

  void _parseDosage(String? dosage) {
    if (dosage == null) return;
    final parts = dosage.split(' ');
    if (parts.length >= 2) {
      dosageController.text = parts[0];
      _dosageUnit = parts.sublist(1).join(' ');
    }
  }

  void _parseTimes(List<dynamic>? timesList) {
    if (_frequencyType == 'يومي') {
      final t = timesList ?? [];
      _selectedTimes = List<TimeOfDay?>.filled(_frequencyNumber, null, growable: true);
      _isAutoGeneratedTimes = List<bool>.filled(_frequencyNumber, false, growable: true);
      for (var i = 0; i < t.length && i < _frequencyNumber; i++) {
        final str = t[i] as String;
        _selectedTimes[i] = EditMedicationUtils.parseTime(str);
      }
    }
  }

  void _parseWeekly(Map<String, dynamic>? freqDetails) {
    if (_frequencyType != 'اسبوعي' || freqDetails == null) return;
    final days = List<int>.from(freqDetails['selectedWeekdays'] ?? []);
    _selectedWeekdays = days.toSet();
    _initializeWeeklySchedule();
  }

  //======== Public setters ========
  void updateDosageUnit(String unit) => _dosageUnit = unit;
  void updateFrequencyType(String type) {
    _frequencyType = type;
    _updateTimeFields();
  }
  void updateFrequencyNumber(int number) {
    _frequencyNumber = number;
    _updateTimeFields();
  }
  void selectDailyTime(int index, TimeOfDay time) {
    if (index < _selectedTimes.length) {
      _selectedTimes[index] = time;
      _isAutoGeneratedTimes[index] = false;
      if (index == 0 && _frequencyType == 'يومي') _autoFillDosageTimes();
    }
  }
  void toggleWeekday(int day, bool isSelected) {
    if (isSelected) {
      if (_selectedWeekdays.length < 6) {
        _selectedWeekdays.add(day);
        if (!_weeklyTimes.containsKey(day)) {
          _weeklyTimes[day] = null;
          _weeklyAutoGenerated[day] = false;
        }
      }
    } else {
      _selectedWeekdays.remove(day);
      _weeklyTimes.remove(day);
      _weeklyAutoGenerated.remove(day);
    }
    _initializeWeeklySchedule();
  }
  void selectWeeklyTime(int day, TimeOfDay time) {
    _weeklyTimes[day] = time;
    _weeklyAutoGenerated[day] = false;
  }
  void updateStartDate(DateTime d) => _startDate = d;
  void updateEndDate(DateTime d) => _endDate = d;

  //======== Internal schedule helpers ========
  void _updateTimeFields() {
    final oldTimes = List<TimeOfDay?>.from(_selectedTimes);
    final oldAuto = List<bool>.from(_isAutoGeneratedTimes);
    _selectedTimes = List.generate(
      _frequencyNumber,
          (i) => i < oldTimes.length ? oldTimes[i] : null,
      growable: true,
    );
    _isAutoGeneratedTimes = List.generate(
      _frequencyNumber,
          (i) => i < oldAuto.length ? oldAuto[i] : false,
      growable: true,
    );
    if (_frequencyType == 'يومي' && _selectedTimes.isNotEmpty && _selectedTimes[0] != null) {
      _autoFillDosageTimes();
    }
  }
  void _autoFillDosageTimes() {
    if (_frequencyType != 'يومي' || _selectedTimes.isEmpty || _selectedTimes[0] == null || _frequencyNumber <= 1) return;
    final first = _selectedTimes[0]!;
    final base = DateTime(2000, 1, 1, first.hour, first.minute);
    final interval = (24 * 60 / _frequencyNumber).round();
    for (var i = 1; i < _frequencyNumber; i++) {
      if (_selectedTimes[i] == null || _isAutoGeneratedTimes[i]) {
        final newTime = base.add(Duration(minutes: interval * i));
        _selectedTimes[i] = TimeOfDay(hour: newTime.hour, minute: newTime.minute);
        _isAutoGeneratedTimes[i] = true;
      }
    }
  }
  void _initializeWeeklySchedule() {
    final newTimes = <int, TimeOfDay?>{};
    final newAuto = <int, bool>{};
    for (var day in _selectedWeekdays) {
      newTimes[day] = _weeklyTimes[day];
      newAuto[day] = _weeklyAutoGenerated[day] ?? false;
    }
    _weeklyTimes = newTimes;
    _weeklyAutoGenerated = newAuto;
  }

  /// Handle capturing an image via camera and uploading.
  Future<void> pickImage() async {
    await EditMedicationUtils.ensureCameraPermission();
    final result = await ImagePicker().pickImage(source: ImageSource.camera);
    if (result == null) return;

    _capturedImage = File(result.path);
    _isUploading = true;
    _uploadedImageUrl = await EditMedicationUtils.uploadToImgBB(File(result.path), imgbbApiKey);
    _isUploading = false;
  }

  /// Commit the changes back to Firestore.
  Future<void> updateMedication(String docId) async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) throw Exception('User not logged in');

    final updated = <String, dynamic>{
      'name': nameController.text.trim(),
      'dosage': '${dosageController.text.trim()} $_dosageUnit',
      'frequencyType': _frequencyType,
      'frequencyDetails': _frequencyType == 'يومي'
          ? {'timesPerDay': _frequencyNumber}
          : {'selectedWeekdays': _selectedWeekdays.toList()..sort()},
      'times': _frequencyType == 'يومي'
          ? _selectedTimes.map((t) => TimeUtils.formatTimeOfDay(t!)).toList()
          : _weeklyTimes.entries.map((e) => {'day': e.key, 'time': TimeUtils.formatTimeOfDay(e.value!)}).toList(),
      'startDate': _startDate != null ? Timestamp.fromDate(_startDate!) : null,
      'endDate':   _endDate   != null ? Timestamp.fromDate(_endDate!)   : null,
      'lastUpdated': Timestamp.now(),
    };
    if (_uploadedImageUrl != null) updated['imageUrl'] = _uploadedImageUrl;

    await FirebaseFirestore.instance
        .collection('users')
        .doc(user.uid)
        .collection('medicines')
        .doc(docId)
        .update(updated);
  }
}



class EditMedicationScreen extends StatefulWidget {
  final String docId;
  const EditMedicationScreen({Key? key, required this.docId}) : super(key: key);
  @override
  _EditMedicationScreenState createState() => _EditMedicationScreenState();
}

class _EditMedicationScreenState extends State<EditMedicationScreen> {
  late final EditMedicationDataProvider dp;

  @override
  void initState() {
    super.initState();
    dp = EditMedicationDataProvider(
      nameController: TextEditingController(),
      dosageController: TextEditingController(),
      imgbbApiKey: '2b30d3479663bc30a70c916363b07c4a',
    );
    dp.init(widget.docId).then((_) {
      if (mounted) setState(() {});
    });
  }

  @override
  void dispose() {
    dp.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (dp.isLoading) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      backgroundColor: kBackgroundColor,
      appBar: AppBar(
        title: const Text('تعديل الدواء'),
        centerTitle: true,
        backgroundColor: kPrimaryColor,
      ),
      body: PageView(
        controller: dp.pageController,
        physics: const NeverScrollableScrollPhysics(),
        children: [
          // Name & Picture Page
          AddNamePicturePage(
            formKey: GlobalKey<FormState>(),
            nameController: dp.nameController,
            medicineNamesFuture: Future.value(dp.medicineNames),
            capturedImage: dp.capturedImage,
            uploadedImageUrl: dp.uploadedImageUrl,
            onPickImage: () async { await dp.pickImage(); setState((){}); },
            onNext: () => dp.pageController.nextPage(
              duration: const Duration(milliseconds: 500),
              curve: Curves.easeInOutCubic,
            ),
            onBack: () => Navigator.pop(context),
          ),

          // Dosage & Timing Page
          AddDosagePage(
            formKey: GlobalKey<FormState>(),
            dosageController: dp.dosageController,
            dosageUnit: dp.dosageUnit,
            dosageUnits: ['ملغم','غرام','مل','وحدة'],
            frequencyType: dp.frequencyType,
            frequencyTypes: ['يومي','اسبوعي'],
            frequencyNumber: dp.frequencyNumber,
            frequencyNumbers: [1,2,3,4,5,6],
            selectedTimes: dp.selectedTimes,
            isAutoGeneratedTimes: dp.isAutoGeneratedTimes,
            selectedWeekdays: dp.selectedWeekdays,
            weeklyTimes: dp.weeklyTimes,
            weeklyAutoGenerated: dp.weeklyAutoGenerated,
            onDosageUnitChanged: (v) => setState(() => dp.updateDosageUnit(v!)),
            onFrequencyTypeChanged: (v) => setState(() => dp.updateFrequencyType(v!)),
            onFrequencyNumberChanged: (v) => setState(() => dp.updateFrequencyNumber(v!)),
            onSelectTime: (i) async {
              final initial = dp.selectedTimes[i] ?? TimeOfDay.now();
              final t = await showTimePicker(
                context: context,
                initialTime: initial,
              );
              if (t != null) setState(() => dp.selectDailyTime(i, t));
            },
            onWeekdaySelected: (d,s) => setState(() => dp.toggleWeekday(d,s)),
            onSelectWeeklyTime: (d) async {
              final initial = dp.weeklyTimes[d] ?? TimeOfDay.now();
              final t = await showTimePicker(
                context: context,
                initialTime: initial,
              );
              if (t != null) setState(() => dp.selectWeeklyTime(d, t));
            },
            onApplySameTimeToAllWeekdays: () => setState(() {
              final days = dp.selectedWeekdays.toList()..sort();
              final base = dp.weeklyTimes[days.first];
              for (var d in days.skip(1)) dp.selectWeeklyTime(d, base!);
            }),
            onNext: () => dp.pageController.nextPage(
              duration: const Duration(milliseconds: 500),
              curve: Curves.easeInOutCubic,
            ),
            onBack: () => dp.pageController.previousPage(
              duration: const Duration(milliseconds: 500),
              curve: Curves.easeInOutCubic,
            ),
            getDayName: (d) => ['','الإثنين','الثلاثاء','الأربعاء','الخميس','الجمعة','السبت','الأحد'][d],
          ),

          // Start & End Date Page
          AddStartEndDatePage(
            formKey: GlobalKey<FormState>(),
            startDate: dp.startDate,
            endDate: dp.endDate,
            onSelectStartDate: () async {
              final d = await showDatePicker(
                context: context,
                initialDate: dp.startDate ?? DateTime.now(),
                firstDate: DateTime(2000),
                lastDate: DateTime.now().add(const Duration(days:3650)),
              );
              if (d != null) setState(() => dp.updateStartDate(d));
            },
            onSelectEndDate: () async {
              final d = await showDatePicker(
                context: context,
                initialDate: dp.endDate ?? dp.startDate ?? DateTime.now(),
                firstDate: dp.startDate ?? DateTime.now(),
                lastDate: DateTime.now().add(const Duration(days:3650)),
              );
              if (d != null) setState(() => dp.updateEndDate(d));
            },
            onSubmit: () async {
              await dp.updateMedication(widget.docId);
              if (mounted) Navigator.pop(context, true);
            },
            onBack: () => dp.pageController.previousPage(
              duration: const Duration(milliseconds: 500),
              curve: Curves.easeInOutCubic,
            ),
          ),
        ],
      ),
    );
  }
}

