import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:image_picker/image_picker.dart';
import 'package:http/http.dart' as http;
import 'package:intl/intl.dart';
import 'package:permission_handler/permission_handler.dart';
// Assuming notification utility is correctly imported from main.dart or its own file
// Make sure this import path is correct for your project structure
import 'package:mudhkir_app/main.dart'; // Or potentially a dedicated notification service file

// Import the new page widgets
import 'Add_Medicaiton/Add_Dosage.dart';
import 'Add_Medicaiton/Add_Name_Picture.dart';
import 'Add_Medicaiton/Add_Start_&_End_Date.dart';

// --------------------
// Time Utilities
// --------------------
class TimeUtils {
  static TimeOfDay? parseTime(String timeStr) {
    // Try parsing with AM/PM format first
    try {
      final DateFormat ampmFormat = DateFormat('h:mm a', 'en_US');
      DateTime parsedDt = ampmFormat.parseStrict(timeStr);
      return TimeOfDay.fromDateTime(parsedDt);
    } catch (_) {}
    // Try parsing with Arabic AM/PM markers
    try {
      String normalizedTime =
      timeStr.replaceAll('صباحاً', 'AM').replaceAll('مساءً', 'PM').trim();
      final DateFormat arabicAmpmFormat = DateFormat('h:mm a', 'en_US');
      DateTime parsedDt = arabicAmpmFormat.parseStrict(normalizedTime);
      return TimeOfDay.fromDateTime(parsedDt);
    } catch (_) {}
    // Try parsing 24-hour format HH:MM
    try {
      final parts = timeStr.split(':');
      if (parts.length == 2) {
        int hour = int.parse(parts[0]);
        // Remove any non-digit characters from minutes (like AM/PM if accidentally included)
        int minute = int.parse(parts[1].replaceAll(RegExp(r'[^0-9]'), ''));
        if (hour >= 0 && hour < 24 && minute >= 0 && minute < 60) {
          return TimeOfDay(hour: hour, minute: minute);
        }
      }
    } catch (_) {}
    // Log failure if all parsing attempts fail
    print("Failed to parse time string: $timeStr");
    return null;
  }

  static String formatTimeOfDay(BuildContext context, TimeOfDay time) {

    final int hour = time.hourOfPeriod == 0 ? 12 : time.hourOfPeriod; // 0 hour is 12 AM
    final String minute = time.minute.toString().padLeft(2, '0');
    // Determine period based on TimeOfDay object
    final String period = time.period == DayPeriod.am ? 'صباحاً' : 'مساءً';
    return '$hour:$minute $period';
  }
}


// --------------------
// AddDose Widget (Main State Holder)
// --------------------
class AddDose extends StatefulWidget {
  const AddDose({super.key});

  @override
  State<AddDose> createState() => _AddDoseState();
}

class _AddDoseState extends State<AddDose> {
  final String imgbbApiKey = '2b30d3479663bc30a70c916363b07c4a';

  final PageController _pageController = PageController();
  final GlobalKey<FormState> _formKeyPage1 = GlobalKey<FormState>();
  final GlobalKey<FormState> _formKeyPage2 = GlobalKey<FormState>();
  final GlobalKey<FormState> _formKeyPage3 = GlobalKey<FormState>();

  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _dosageController = TextEditingController();
  String _dosageUnit = 'ملغم'; // Default value
  List<TimeOfDay?> _selectedTimes = [];
  List<bool> _isAutoGeneratedTimes = [];
  String _frequencyType = 'يومي'; // Default value
  int _frequencyNumber = 1; // Default value
  DateTime? _startDate = DateTime.now(); // Default value
  DateTime? _endDate;
  late Future<List<String>> _medicineNamesFuture;

  File? _capturedImage;
  String? _uploadedImageUrl;
  bool _isUploading = false; // Track upload state

  // Options lists
  final List<String> _dosageUnits = ['ملغم', 'غرام', 'مل', 'وحدة'];
  final List<String> _frequencyTypes = ['يومي', 'اسبوعي'];
  final List<int> _frequencyNumbers = [1, 2, 3, 4, 5, 6];

  // Weekly scheduling state
  Map<int, TimeOfDay?> _weeklyTimes = {};
  Map<int, bool> _weeklyAutoGenerated = {};
  Set<int> _selectedWeekdays = {};

  // --- Lifecycle Methods ---
  @override
  void initState() {
    super.initState();
    _medicineNamesFuture = _loadMedicineNames();
    _selectedTimes = List.filled(_frequencyNumber, null, growable: true);
    _isAutoGeneratedTimes = List.filled(_frequencyNumber, false, growable: true);
  }

  @override
  void dispose() {
    _nameController.dispose();
    _dosageController.dispose();
    _pageController.dispose();
    super.dispose();
  }

  // --- Data Loading ---
  Future<List<String>> _loadMedicineNames() async {
    try {
      final String jsonString = await rootBundle.loadString('assets/Mediciens/trade_names.json');
      final List<dynamic> jsonList = json.decode(jsonString);
      return jsonList.map((item) => item.toString()).toList();
    } catch (e) {
      print('Error loading medicine names: $e');
      if (mounted) { // Check if widget is still in the tree
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('حدث خطأ أثناء تحميل قائمة الأدوية')),
        );
      }
      return []; // Return empty list on error
    }
  }

  // --- State Update Logic ---

  void _updateTimeFields() {
    setState(() {
      List<TimeOfDay?> oldTimes = List.from(_selectedTimes);
      List<bool> oldAutoGenerated = List.from(_isAutoGeneratedTimes);

      _selectedTimes = List.generate(
          _frequencyNumber,
              (index) => index < oldTimes.length ? oldTimes[index] : null,
          growable: true);
      _isAutoGeneratedTimes = List.generate(
          _frequencyNumber,
              (index) => index < oldAutoGenerated.length ? oldAutoGenerated[index] : false,
          growable: true);

      if (_frequencyType == 'يومي' && _selectedTimes.isNotEmpty && _selectedTimes[0] != null) {
        _autoFillDosageTimes(); // This function now calls setState internally
      }
    });
  }


  /// Auto-fill remaining daily dosage times based on the first dose.
  void _autoFillDosageTimes() {
    if (_frequencyType != 'يومي' || _selectedTimes.isEmpty || _selectedTimes[0] == null || _frequencyNumber <= 1) {
      return;
    }

    final firstDose = _selectedTimes[0]!;
    DateTime base = DateTime(2000, 1, 1, firstDose.hour, firstDose.minute);
    int intervalMinutes = (24 * 60 / _frequencyNumber).round();

    List<TimeOfDay?> newTimes = List.from(_selectedTimes);
    List<bool> newAutoGenerated = List.from(_isAutoGeneratedTimes);
    bool changed = false;

    for (int i = 1; i < _frequencyNumber; i++) {
      if (newTimes[i] == null || newAutoGenerated[i]) {
        DateTime newTime = base.add(Duration(minutes: intervalMinutes * i));
        TimeOfDay newTimeOfDay = TimeOfDay(hour: newTime.hour, minute: newTime.minute);
        if (newTimes[i] != newTimeOfDay || !newAutoGenerated[i]) {
          newTimes[i] = newTimeOfDay;
          newAutoGenerated[i] = true;
          changed = true;
        }
      }
    }
    if (changed && mounted) {
      setState(() {
        _selectedTimes = newTimes;
        _isAutoGeneratedTimes = newAutoGenerated;
      });
    }
  }


  /// Initialize or update weekly schedule maps based on selected weekdays.
  void _initializeWeeklySchedule() {
    // This function modifies state, so wrap in setState
    setState(() {
      Map<int, TimeOfDay?> updatedWeeklyTimes = {};
      Map<int, bool> updatedWeeklyAutoGenerated = {};

      // Iterate over currently selected weekdays
      for (int day in _selectedWeekdays) {
        updatedWeeklyTimes[day] = _weeklyTimes[day]; // Keep existing time if present
        updatedWeeklyAutoGenerated[day] = _weeklyAutoGenerated[day] ?? false; // Keep existing flag or default to false
      }
      _weeklyTimes = updatedWeeklyTimes;
      _weeklyAutoGenerated = updatedWeeklyAutoGenerated;
    });
  }

  // --- UI Interaction Callbacks ---

  Future<void> _selectStartDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _startDate ?? DateTime.now(),
      firstDate: DateTime(2000), // Allow past dates for start
      lastDate: DateTime(DateTime.now().year + 10), // Extend range
      // locale: const Locale('ar', 'SA'),
    );
    if (picked != null && picked != _startDate && mounted) { // Check mounted
      setState(() {
        _startDate = picked;
        if (_endDate != null && _endDate!.isBefore(picked)) {
          _endDate = null;
        }
      });
    }
  }

  Future<void> _selectEndDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _endDate ?? _startDate ?? DateTime.now(),
      // Ensure firstDate is not before startDate
      firstDate: _startDate ?? DateTime.now().subtract(const Duration(days: 1)),
      lastDate: DateTime(DateTime.now().year + 10),
      // locale: const Locale('ar', 'SA'),
    );
    if (picked != null && picked != _endDate && mounted) { // Check mounted
      setState(() => _endDate = picked);
    }
  }

  Future<void> _selectTime(int index) async {
    final TimeOfDay initialTime = _selectedTimes.length > index && _selectedTimes[index] != null
        ? _selectedTimes[index]!
        : TimeOfDay.now();

    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: initialTime,
    );

    if (picked != null && mounted) { // Check mounted
      setState(() {
        // Ensure list is long enough before accessing index
        if (index < _selectedTimes.length) {
          _selectedTimes[index] = picked;
          _isAutoGeneratedTimes[index] = false;
          // If the first time is changed, re-trigger auto-fill for others
          if (index == 0 && _frequencyType == 'يومي') {
            _autoFillDosageTimes(); // This now calls setState internally if needed
          }
        }
      });
    }
  }


  Future<void> _selectWeeklyTime(int day) async {
    final TimeOfDay initialTime = _weeklyTimes[day] ?? TimeOfDay.now();
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: initialTime,
    );
    if (picked != null && mounted) {
      setState(() {
        _weeklyTimes[day] = picked;
        _weeklyAutoGenerated[day] = false;
      });
    }
  }

  /// Callback for when a weekday chip is selected/deselected.
  void _handleWeekdaySelected(int day, bool isSelected) {
    // Modifies state, wrap in setState
    setState(() {
      if (isSelected) {
        if (_selectedWeekdays.length < 6) {
          _selectedWeekdays.add(day);
          if (!_weeklyTimes.containsKey(day)) {
            _weeklyTimes[day] = null;
            _weeklyAutoGenerated[day] = false;
          }
        } else {
          // Show feedback if limit reached
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('يمكنك اختيار 6 أيام فقط كحد أقصى')),
          );
        }
      } else {
        _selectedWeekdays.remove(day);
        _weeklyTimes.remove(day);
        _weeklyAutoGenerated.remove(day);
      }
    });
  }

  /// Callback to apply the time of the first selected weekday to others.
  void _handleApplySameTimeToAllWeekdays() {
    List<int> sortedDays = _selectedWeekdays.toList()..sort();
    if (sortedDays.isEmpty || _weeklyTimes[sortedDays.first] == null) {
      // Show feedback if condition not met
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("الرجاء تحديد وقت لليوم الأول في القائمة أولاً")),
      );
      return;
    }

    final firstTime = _weeklyTimes[sortedDays.first]!;
    bool changed = false; // Track changes

    // Modify state, wrap in setState
    setState(() {
      for (int day in sortedDays.skip(1)) {
        if (_weeklyTimes[day] == null || (_weeklyAutoGenerated[day] ?? false)) {
          if (_weeklyTimes[day] != firstTime || !(_weeklyAutoGenerated[day] ?? false)) {
            _weeklyTimes[day] = firstTime;
            _weeklyAutoGenerated[day] = true;
            changed = true;
          }
        }
      }
    });
    if (changed) {
      print("Applied same time to other weekdays.");
    }
  }


  // --- Image Handling ---
  Future<void> _pickImage() async {
    File? tempImage;
    bool wasUploading = _isUploading;

    try {
      // Request camera permission explicitly
      var status = await Permission.camera.request();
      if (status.isGranted) {
        final pickedFile = await ImagePicker().pickImage(source: ImageSource.camera);
        if (pickedFile != null) {
          tempImage = File(pickedFile.path);
          if (mounted) { // Check mounted before setState
            setState(() {
              _capturedImage = tempImage; // Update the state variable
              _uploadedImageUrl = null; // Reset URL when new image is picked
              _isUploading = true; // Start showing progress indicator
            });
          }
          // Start upload in background, handle errors
          // Use the tempImage variable for the upload function
          _uploadImageToImgBB(tempImage).then((url) {
            if (mounted) {
              setState(() {
                _uploadedImageUrl = url;
                _isUploading = false;
              });
            }
          }).catchError((e) {
            print("Error during image upload: $e");
            if (mounted) { // Check mounted before error setState
              setState(() {
                _isUploading = false; // Stop progress on error
                // Decide if you want to clear the image on error
                // _capturedImage = null;
              });
              _showBlockingAlert("خطأ تحميل", "فشل تحميل الصورة. الرجاء المحاولة مرة أخرى.");
            }
          });
        } else {
          // User cancelled the picker
          if (mounted && wasUploading) { // If was uploading before cancel, reset state
            setState(() { _isUploading = false; });
          }
        }
      } else if (status.isPermanentlyDenied) {
        // Guide user to settings if permanently denied
        _showBlockingAlert(
            "الإذن مطلوب",
            "تم رفض الوصول إلى الكاميرا بشكل دائم. يرجى تمكين الإذن من إعدادات التطبيق.",
            onOk: openAppSettings // Requires permission_handler package
        );
        if (mounted && wasUploading) { setState(() { _isUploading = false; }); }

      } else {
        // Inform user if permission denied temporarily
        _showBlockingAlert("الإذن مطلوب", "يجب السماح بالوصول إلى الكاميرا لالتقاط صورة.");
        if (mounted && wasUploading) { setState(() { _isUploading = false; }); }
      }
    } catch (e) {
      print("Image picker error: $e");
      if (mounted) { // Check mounted before error setState
        setState(() { _isUploading = false; }); // Ensure uploading stops on error
        _showBlockingAlert("خطأ", "حدث خطأ أثناء التقاط الصورة.");
      }
    }
  }


  Future<String?> _uploadImageToImgBB(File imageFile) async {
    // This function runs in the background, no setState needed here.
    try {
      final bytes = await imageFile.readAsBytes();
      final base64Image = base64Encode(bytes);
      final url = Uri.parse('https://api.imgbb.com/1/upload?key=$imgbbApiKey');

      // Consider adding a timeout to the request
      final response = await http.post(url, body: {'image': base64Image})
          .timeout(const Duration(seconds: 60)); // Example: 60 second timeout

      if (response.statusCode == 200) {
        final jsonResponse = json.decode(response.body);
        // Safely access the URL, checking for nulls
        final imageUrl = jsonResponse['data']?['url'] as String?;
        if (imageUrl != null) {
          print("Image uploaded to ImgBB: $imageUrl");
          return imageUrl; // Return the URL
        } else {
          print("ImgBB response missing image URL: ${response.body}");
          throw Exception("فشل تحميل الصورة: لم يتم العثور على رابط الصورة في الاستجابة.");
        }
      } else {
        print("ImgBB upload failed: Status Code ${response.statusCode}, Body: ${response.body}");
        // Throw an error with more context
        throw Exception("فشل تحميل الصورة. رمز الحالة: ${response.statusCode}");
      }
    } on TimeoutException {
      print("Error uploading image to ImgBB: Request timed out.");
      throw Exception("فشل تحميل الصورة: انتهت مهلة الطلب.");
    } catch (e) {
      print("Error uploading image to ImgBB: $e");
      // Re-throw a user-friendly error or the original exception
      throw Exception("حدث خطأ غير متوقع أثناء تحميل الصورة: $e");
    }
  }


  // --- Navigation and Submission ---

  void _nextPage() {
    if (!_pageController.hasClients) return; // Avoid error if called before mounted
    _pageController.nextPage(
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }

  void _previousPage() {
    if (!_pageController.hasClients) return;
    _pageController.previousPage(
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }

  /// Final submission logic.
  Future<void> _submitForm() async {
    //  Validate the final form page first
    if (!_formKeyPage3.currentState!.validate()) {
      print("Form Page 3 validation failed.");
      return;
    }

    //  Check if an image was picked but is still uploading
    if (_capturedImage != null && _isUploading) {
      _showBlockingAlert("انتظار", "يتم تحميل الصورة حالياً. الرجاء الانتظار لحظات ثم المحاولة مرة أخرى.");
      return;
    }

    //  Validate weekly schedule specifics if type is weekly
    if (_frequencyType == 'اسبوعي') {
      if (_selectedWeekdays.isEmpty) {
        _showBlockingAlert("خطأ", "الرجاء تحديد يوم واحد على الأقل للجدول الأسبوعي.");
        return;
      }
      // Ensure all selected weekdays have a time picked
      bool allWeeklyTimesSet = _selectedWeekdays.every((day) => _weeklyTimes[day] != null);
      if (!allWeeklyTimesSet) {
        _showBlockingAlert("خطأ", "الرجاء تحديد وقت لكل يوم تم اختياره في الجدول الأسبوعي.");
        return;
      }
    }

    // 4. Check user authentication
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      _showBlockingAlert("خطأ", "المستخدم غير مسجل الدخول.");
      return;
    }

    // --- 5. Prepare Data for Firestore ---
    List<String> dailyTimesFormatted = [];
    List<Map<String, dynamic>> weeklyScheduleFormatted = [];
    List<Map<String, dynamic>> initialMissedDoses = []; // Keep this structure

    if (_frequencyType == 'يومي') {
      dailyTimesFormatted = _selectedTimes
          .where((t) => t != null)
          .map((t) => TimeUtils.formatTimeOfDay(context, t!)) // Use utility function
          .toList();

      // Populate initialMissedDoses for daily schedule
      for (var time in _selectedTimes) {
        if (time != null && _startDate != null) {
          // Use start date for the initial schedule date, time from selection
          DateTime doseDateTime = DateTime(
              _startDate!.year, _startDate!.month, _startDate!.day,
              time.hour, time.minute
          );
          // Add all initial doses regardless of whether they are past or future
          initialMissedDoses.add({
            'scheduled': Timestamp.fromDate(doseDateTime),
            'status': 'pending' // Initial status
          });
        }
      }

    } else { // Weekly
      List<int> sortedDays = _selectedWeekdays.toList()..sort();
      weeklyScheduleFormatted = sortedDays.map((day) {
        final time = _weeklyTimes[day];
        return {
          'day': day, // Store ISO weekday number (1=Mon, 7=Sun)
          'time': time != null ? TimeUtils.formatTimeOfDay(context, time) : '' // Store formatted time string
        };
      }).toList();

      // Populate initialMissedDoses for weekly schedule for the first week
      if (_startDate != null) {
        DateTime currentCheckDate = _startDate!;
        DateTime firstWeekEndDate = _startDate!.add(const Duration(days: 7));
        // Consider the actual end date if it's within the first week
        DateTime effectiveEndDate = _endDate != null && _endDate!.isBefore(firstWeekEndDate)
            ? _endDate!.add(const Duration(days: 1)) // Include end date itself
            : firstWeekEndDate;

        while(currentCheckDate.isBefore(effectiveEndDate)) {
          if (_selectedWeekdays.contains(currentCheckDate.weekday)) {
            final time = _weeklyTimes[currentCheckDate.weekday];
            if (time != null) {
              DateTime doseDateTime = DateTime(
                  currentCheckDate.year, currentCheckDate.month, currentCheckDate.day,
                  time.hour, time.minute
              );
              initialMissedDoses.add({
                'scheduled': Timestamp.fromDate(doseDateTime),
                'status': 'pending'
              });
            }
          }
          currentCheckDate = currentCheckDate.add(const Duration(days: 1));
        }
      }
    }

    // Construct the final data object
    final newMedicine = <String, dynamic>{
      'userId': user.uid,
      'name': _nameController.text.trim(),
      'dosage': '${_dosageController.text.trim()} $_dosageUnit',
      'frequencyType': _frequencyType, // Store type ('يومي' or 'اسبوعي')
      // Store frequency details based on type
      'frequencyDetails': _frequencyType == 'يومي'
          ? {'timesPerDay': _frequencyNumber}
          : {'selectedWeekdays': _selectedWeekdays.toList()..sort()}, // Store selected days
      'times': _frequencyType == 'يومي' ? dailyTimesFormatted : weeklyScheduleFormatted, // Store appropriate schedule
      'startDate': _startDate != null ? Timestamp.fromDate(_startDate!) : null,
      'endDate': _endDate != null ? Timestamp.fromDate(_endDate!) : null,
      'createdAt': FieldValue.serverTimestamp(),
      'missedDoses': initialMissedDoses, // Store the initial list
      'lastUpdated': Timestamp.now(), // Track last update
      'isActive': true, // Default to active
      // Add image URL only if it was successfully uploaded
      if (_uploadedImageUrl != null && _uploadedImageUrl!.isNotEmpty)
        'imageUrl': _uploadedImageUrl,
    };

    // Handle case where image upload failed but user tries to submit
    if (_capturedImage != null && (_uploadedImageUrl == null || _uploadedImageUrl!.isEmpty) && !_isUploading) {
      print("⚠️ Image was captured but upload failed or URL is missing.");
      // Decide how to handle: allow submit without image, or block?
      bool allowSubmitWithoutImage = false; // Set to true to allow, false to block
      if (!allowSubmitWithoutImage) {
        _showBlockingAlert("خطأ", "فشل تحميل الصورة. لا يمكن حفظ الدواء بدون صورة حالياً.");
        return; // Block submission
      }
    }


    // --- Firestore Operation ---
    try {
      print("Attempting to add medication: ${newMedicine['name']}");
      final docRef = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .collection('medicines')
          .add(newMedicine);

      print("✅ Medication added with ID: ${docRef.id}");

      // ---  Schedule Notifications ---
      // Use a base notification ID and increment for uniqueness within this add operation
      int baseNotificationId = docRef.id.hashCode.abs() % 2147483647;
      int notificationCounter = 0;

      // Schedule based on frequency type
      if (_frequencyType == 'يومي') {
        for (var time in _selectedTimes) {
          if (time != null) {
            print("Scheduling DAILY notification for ${newMedicine['name']} at $time");
            // Replace with your actual notification scheduling call
            await scheduleDailyRepeatingNotification(
              id: baseNotificationId + notificationCounter++,
              title: 'تذكير الدواء',
              body: 'حان وقت تناول ${_nameController.text.trim()}',
              timeOfDay: time,
              payload: docRef.id,
              startDate: _startDate,
              endDate: _endDate,
            );
          }
        }
      } else { // Weekly
        for (int day in _selectedWeekdays) {
          final time = _weeklyTimes[day];
          if (time != null) {
            print("Scheduling WEEKLY notification for ${newMedicine['name']} on day $day at $time");
            await scheduleWeeklyRepeatingNotification(
              id: baseNotificationId + notificationCounter++,
              title: 'تذكير الدواء',
              body: 'حان وقت تناول ${_nameController.text.trim()}',
              weekday: day,
              timeOfDay: time,
              payload: docRef.id,
              startDate: _startDate,
              endDate: _endDate,
            );
          }
        }
      }

      //  Success feedback and navigation
      if (mounted) { // Check mounted before showing dialog/popping
        _showBlockingAlert("نجاح", "تمت إضافة الدواء وجدولة التذكيرات بنجاح!", onOk: () {
          if (mounted) Navigator.pop(context, true); // Pop back, indicating success
        });
      }

    } catch (e, s) { // Catch error and stack trace
      print("❌ Firestore/Scheduling error: $e");
      print("❌ Stack trace: $s");
      if (mounted) { // Check mounted before showing error
        _showBlockingAlert("خطأ", "حدث خطأ أثناء حفظ الدواء أو جدولة التذكيرات: $e");
      }
    }
  }


  // --- Helper Functions ---

  /// Shows a non-dismissible alert dialog.
  void _showBlockingAlert(String title, String message, {VoidCallback? onOk}) {
    if (!mounted) return; // Don't show dialog if widget is disposed
    showDialog(
      context: context,
      barrierDismissible: false, // Make it non-dismissible until OK is pressed
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(title, textAlign: TextAlign.center),
          content: Text(message, textAlign: TextAlign.center),
          actionsAlignment: MainAxisAlignment.center,
          actions: [
            TextButton(
              child: const Text("حسناً"),
              onPressed: () {
                Navigator.of(context).pop(); // Close the dialog
                onOk?.call(); // Execute callback if provided
              },
            )
          ],
        );
      },
    );
  }

  /// Returns the Arabic name for a given ISO weekday number (1=Mon, 7=Sun).
  String _dayName(int day) {
    // Ensure day is within 1-7 range
    switch (day) {
      case 1: return "الإثنين";
      case 2: return "الثلاثاء";
      case 3: return "الأربعاء";
      case 4: return "الخميس";
      case 5: return "الجمعة";
      case 6: return "السبت";
      case 7: return "الأحد"; // Sunday is 7 in ISO 8601 standard
      default: return "";
    }
  }

  // --- Mock/Placeholder Notification Scheduling Functions ---
  Future<void> scheduleDailyRepeatingNotification({
    required int id, required String title, required String body,
    required TimeOfDay timeOfDay, String? payload, DateTime? startDate, DateTime? endDate}) async {
    print("[MOCK] Scheduling Daily Notification: ID=$id, Title=$title, Time=${timeOfDay.format(context)}, Start=$startDate, End=$endDate, Payload=$payload");
    await Future.delayed(const Duration(milliseconds: 50)); // Simulate async operation
  }

  Future<void> scheduleWeeklyRepeatingNotification({
    required int id, required String title, required String body,
    required int weekday, required TimeOfDay timeOfDay, String? payload, DateTime? startDate, DateTime? endDate}) async {
    print("[MOCK] Scheduling Weekly Notification: ID=$id, Title=$title, Weekday=$weekday, Time=${timeOfDay.format(context)}, Start=$startDate, End=$endDate, Payload=$payload");
    await Future.delayed(const Duration(milliseconds: 50)); // Simulate async operation
  }


  // --- Build Method ---
  @override
  Widget build(BuildContext context) {
    // Use GestureDetector to dismiss keyboard when tapping outside fields
    return GestureDetector(
      onTap: () => FocusScope.of(context).unfocus(),
      child: Scaffold(
        body: Stack(
          children: [
            Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [Colors.blue.shade50, Colors.white, Colors.grey.shade50],
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                ),
              ),
            ),
            // PageView to host the different steps
            PageView(
              controller: _pageController,
              // Disable swiping between pages, navigation is controlled by buttons
              physics: const NeverScrollableScrollPhysics(),
              children: [
                // --- Page 1 ---
                AddNamePicturePage(
                  formKey: _formKeyPage1,
                  nameController: _nameController,
                  medicineNamesFuture: _medicineNamesFuture,
                  capturedImage: _capturedImage,
                  // Pass the uploading state to show progress correctly
                  uploadedImageUrl: _uploadedImageUrl, // Used to determine if upload finished
                  onPickImage: _pickImage,
                  onNext: () {
                    // Validate before moving next
                    if (_formKeyPage1.currentState!.validate()) {
                      // Check if image is currently uploading
                      if (_capturedImage != null && _isUploading) {
                        _showBlockingAlert("انتظار", "يتم تحميل الصورة حالياً. الرجاء الانتظار.");
                      } else {
                        _nextPage();
                      }
                    }
                  },
                  onBack: () => Navigator.pop(context), // Exit on back from first page
                ),
                // --- Page 2 ---
                AddDosagePage(
                  formKey: _formKeyPage2,
                  dosageController: _dosageController,
                  dosageUnit: _dosageUnit,
                  dosageUnits: _dosageUnits,
                  frequencyType: _frequencyType,
                  frequencyTypes: _frequencyTypes,
                  frequencyNumber: _frequencyNumber,
                  frequencyNumbers: _frequencyNumbers,
                  selectedTimes: _selectedTimes,
                  isAutoGeneratedTimes: _isAutoGeneratedTimes,
                  selectedWeekdays: _selectedWeekdays,
                  weeklyTimes: _weeklyTimes,
                  weeklyAutoGenerated: _weeklyAutoGenerated,
                  onDosageUnitChanged: (value) {
                    if (value != null && mounted) setState(() => _dosageUnit = value); // Check mounted
                  },
                  onFrequencyNumberChanged: (value) {
                    if (value != null && value != _frequencyNumber && mounted) { // Check mounted
                      setState(() => _frequencyNumber = value);
                      _updateTimeFields(); // Update times when number changes
                    }
                  },
                  onFrequencyTypeChanged: (value) {
                    if (value != null && value != _frequencyType && mounted) { // Check mounted
                      setState(() {
                        _frequencyType = value;
                        // Reset/initialize schedules based on new type
                        if (value == 'يومي') {
                          // Re-init daily fields (will call setState internally if needed)
                          _updateTimeFields();
                          // Clear weekly selections
                          _selectedWeekdays.clear();
                          _weeklyTimes.clear();
                          _weeklyAutoGenerated.clear();
                        } else { // Weekly
                          // Clear daily selections
                          _selectedTimes = List.filled(_frequencyNumber, null, growable: true);
                          _isAutoGeneratedTimes = List.filled(_frequencyNumber, false, growable: true);
                          // Init weekly fields (will call setState internally)
                          _initializeWeeklySchedule();
                        }
                      });
                    }
                  },
                  onSelectTime: _selectTime, // Pass daily time selection callback
                  onWeekdaySelected: _handleWeekdaySelected, // Pass weekly day toggle callback
                  onSelectWeeklyTime: _selectWeeklyTime, // Pass weekly time selection callback
                  onApplySameTimeToAllWeekdays: _handleApplySameTimeToAllWeekdays,
                  onNext: () {
                    // Validate before moving next
                    if (_formKeyPage2.currentState!.validate()) {
                      // Additional check: Ensure all required times are filled
                      bool allTimesFilled = _frequencyType == 'يومي'
                          ? _selectedTimes.every((t) => t != null)
                          : (_selectedWeekdays.isEmpty || _selectedWeekdays.every((day) => _weeklyTimes[day] != null));

                      if (allTimesFilled) {
                        _nextPage();
                      } else {
                        // Show feedback if times are missing
                        ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(content: Text('الرجاء تحديد جميع أوقات الجرعات المطلوبة.'))
                        );
                      }
                    }
                  },
                  onBack: _previousPage, // Go back to page 1
                  getDayName: _dayName, // Pass day name function
                ),
                // --- Page 3 ---
                AddStartEndDatePage(
                  formKey: _formKeyPage3,
                  startDate: _startDate,
                  endDate: _endDate,
                  onSelectStartDate: _selectStartDate,
                  onSelectEndDate: _selectEndDate,
                  // New clear callback to allow removing the end date
                  onClearEndDate: () => setState(() => _endDate = null),
                  onSubmit: _submitForm, // Call the final submit logic
                  onBack: _previousPage, // Go back to page 2
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
