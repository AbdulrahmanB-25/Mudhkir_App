import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:image_picker/image_picker.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:http/http.dart' as http;
import 'package:intl/intl.dart';

import '../MeidcaitonDetailPage_Utility/medication_detail_ui_components.dart';
import 'Add_Medicaiton/Add_Dosage.dart' show AddDosagePage;
import 'Add_Medicaiton/Add_Name_Picture.dart' show AddNamePicturePage;
import 'Add_Medicaiton/Add_Start_&_End_Date.dart' show AddStartEndDatePage;

/// Provides all data-loading, state, and update logic for editing a medication.
class EditMedicationDataProvider {
  // Controllers
  final TextEditingController nameController;
  final TextEditingController dosageController;
  final PageController pageController = PageController();

  // ImgBB API key
  final String imgbbApiKey;

  // Internal state
  bool _isLoading = true;
  bool get isLoading => _isLoading;

  File? _capturedImage;
  String? _uploadedImageUrl;
  bool _isUploading = false;
  bool get isUploading => _isUploading;
  bool get hasOriginalImage => _hasOriginalImage;
  bool _hasOriginalImage = false;

  List<String> _medicineNames = [];
  List<String> get medicineNames => _medicineNames;

  String _dosageUnit = 'ملغم';
  String get dosageUnit => _dosageUnit;

  String _frequencyType = 'يومي';
  String get frequencyType => _frequencyType;

  int _frequencyNumber = 1;
  int get frequencyNumber => _frequencyNumber;

  List<TimeOfDay?> _selectedTimes = [];
  List<TimeOfDay?> get selectedTimes => _selectedTimes;

  List<bool> _isAutoGeneratedTimes = [];
  List<bool> get isAutoGeneratedTimes => _isAutoGeneratedTimes;

  Set<int> _selectedWeekdays = {};
  Set<int> get selectedWeekdays => _selectedWeekdays;

  Map<int, TimeOfDay?> _weeklyTimes = {};
  Map<int, TimeOfDay?> get weeklyTimes => _weeklyTimes;

  Map<int, bool> _weeklyAutoGenerated = {};
  Map<int, bool> get weeklyAutoGenerated => _weeklyAutoGenerated;

  DateTime? _startDate;
  DateTime? get startDate => _startDate;
  DateTime? _endDate;
  DateTime? get endDate => _endDate;

  List<int> _originalNotificationIds = [];

  EditMedicationDataProvider({
    required this.nameController,
    required this.dosageController,
    required this.imgbbApiKey,
  });

  /// Initialize by loading names and existing medication data.
  Future<void> init(String docId) async {
    _isLoading = true;
    await _loadMedicineNames();
    await loadMedicationData(docId);
    _isLoading = false;
  }

  void dispose() {
    nameController.dispose();
    dosageController.dispose();
    pageController.dispose();
  }

  Future<void> _loadMedicineNames() async {
    try {
      final raw = await rootBundle.loadString('assets/Mediciens/trade_names.json');
      final list = json.decode(raw) as List<dynamic>;
      _medicineNames = list.map((e) => e.toString()).toList();
    } catch (_) {
      _medicineNames = [];
    }
  }

  Future<void> loadMedicationData(String docId) async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) throw Exception('User not logged in');

    final doc = await FirebaseFirestore.instance
        .collection('users')
        .doc(user.uid)
        .collection('medicines')
        .doc(docId)
        .get();
    if (!doc.exists) throw Exception('Medicine not found');

    final data = doc.data()!;
    nameController.text = data['name'] ?? '';
    _parseDosage(data['dosage'] as String?);
    _frequencyType = data['frequencyType'] ?? 'يومي';
    _frequencyNumber = (data['frequencyDetails']?['timesPerDay'] as int?) ?? 1;
    _parseTimes(data['times'] as List<dynamic>?);
    _parseWeekly(data['frequencyDetails'] as Map<String, dynamic>?);

    _startDate = (data['startDate'] as Timestamp?)?.toDate();
    _endDate   = (data['endDate']   as Timestamp?)?.toDate();

    final url = data['imageUrl'] as String?;
    if (url != null && url.isNotEmpty) {
      _uploadedImageUrl = url;
      _hasOriginalImage = true;
    }

    _originalNotificationIds = List<int>.from(data['notificationIds'] ?? []);
  }

  void _parseDosage(String? dosage) {
    if (dosage == null) return;
    final parts = dosage.split(' ');
    if (parts.length >= 2) {
      dosageController.text = parts[0];
      _dosageUnit = parts.sublist(1).join(' ');
    }
  }

  void _parseTimes(List<dynamic>? timesList) {
    if (_frequencyType == 'يومي') {
      final t = timesList ?? [];
      _selectedTimes = List<TimeOfDay?>.filled(_frequencyNumber, null, growable: true);
      _isAutoGeneratedTimes = List<bool>.filled(_frequencyNumber, false, growable: true);
      for (var i = 0; i < t.length && i < _frequencyNumber; i++) {
        final str = t[i] as String;
        _selectedTimes[i] = TimeUtils.parseTime(str);
      }
    }
  }

  void _parseWeekly(Map<String, dynamic>? freqDetails) {
    if (_frequencyType != 'اسبوعي' || freqDetails == null) return;
    final days = List<int>.from(freqDetails['selectedWeekdays'] ?? []);
    _selectedWeekdays = days.toSet();
  }

  /// Handle capturing an image via camera and uploading.
  Future<void> pickImage() async {
    await EditMedicationUtils.ensureCameraPermission();
    final result = await ImagePicker().pickImage(source: ImageSource.camera);
    if (result == null) return;

    _capturedImage = File(result.path);
    _isUploading = true;
    _uploadedImageUrl = await EditMedicationUtils.uploadToImgBB(File(result.path), imgbbApiKey);
    _isUploading = false;
  }

  /// Commit the changes back to Firestore.
  Future<void> updateMedication(String docId) async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) throw Exception('User not logged in');

    final updated = <String, dynamic>{
      'name': nameController.text.trim(),
      'dosage': '${dosageController.text.trim()} $_dosageUnit',
      'frequencyType': _frequencyType,
      'frequencyDetails': _frequencyType == 'يومي'
          ? {'timesPerDay': _frequencyNumber}
          : {'selectedWeekdays': _selectedWeekdays.toList()..sort()},
      'times': _frequencyType == 'يومي'
          ? _selectedTimes.map((t) => TimeUtils.formatTimeOfDay(t!)).toList()
          : _weeklyTimes.entries
          .map((e) => {'day': e.key, 'time': TimeUtils.formatTimeOfDay(e.value!)})
          .toList(),
      'startDate': _startDate != null ? Timestamp.fromDate(_startDate!) : null,
      'endDate':   _endDate   != null ? Timestamp.fromDate(_endDate!)   : null,
      'lastUpdated': Timestamp.now(),
    };
    if (_uploadedImageUrl != null) updated['imageUrl'] = _uploadedImageUrl;

    await FirebaseFirestore.instance
        .collection('users')
        .doc(user.uid)
        .collection('medicines')
        .doc(docId)
        .update(updated);
  }

  void updateStartDate(DateTime date) {
    _startDate = date;
  }

  void updateEndDate(DateTime? date) {
    _endDate = date;
  }
}

/// Basic time parsing/formatting utilities.
class TimeUtils {
  static TimeOfDay? parseTime(String timeStr) {
    try {
      final f = DateFormat('h:mm a', 'ar');
      return TimeOfDay.fromDateTime(f.parseStrict(timeStr));
    } catch (_) {}
    return null;
  }

  static String formatTimeOfDay(TimeOfDay t) {
    final dt = DateTime(0, 0, 0, t.hour, t.minute);
    return DateFormat.jm('ar').format(dt);
  }
}


class EditMedicationScreen extends StatefulWidget {
  final String docId;
  const EditMedicationScreen({Key? key, required this.docId}) : super(key: key);
  @override
  _EditMedicationScreenState createState() => _EditMedicationScreenState();
}

class _EditMedicationScreenState extends State<EditMedicationScreen> {
  late final EditMedicationDataProvider dp;

  @override
  void initState() {
    super.initState();
    dp = EditMedicationDataProvider(
      nameController: TextEditingController(),
      dosageController: TextEditingController(),
      imgbbApiKey: '2b30d3479663bc30a70c916363b07c4a',
    );
    dp.init(widget.docId).then((_) {
      if (mounted) setState(() {});
    });
  }

  @override
  void dispose() {
    dp.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (dp.isLoading) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      backgroundColor: kBackgroundColor,
      appBar: AppBar(
        title: const Text('تعديل الدواء'),
        centerTitle: true,
        backgroundColor: kPrimaryColor,
      ),
      body: PageView(
        controller: dp.pageController,
        physics: const NeverScrollableScrollPhysics(),
        children: [
          AddNamePicturePage(
            formKey: GlobalKey<FormState>(),
            nameController: dp.nameController,
            medicineNamesFuture: Future.value(dp.medicineNames),
            capturedImage: dp._capturedImage,
            uploadedImageUrl: dp._uploadedImageUrl,
            onPickImage: () async { await dp.pickImage(); setState((){}); },
            onNext: () => dp.pageController.nextPage(
              duration: const Duration(milliseconds: 500),
              curve: Curves.easeInOutCubic,
            ),
            onBack: () => Navigator.pop(context),
          ),

          AddDosagePage(
            formKey: GlobalKey<FormState>(),
            dosageController: dp.dosageController,
            dosageUnit: dp.dosageUnit,
            dosageUnits: ['ملغم','غرام','مل','وحدة'],
            frequencyType: dp.frequencyType,
            frequencyTypes: ['يومي','اسبوعي'],
            frequencyNumber: dp.frequencyNumber,
            frequencyNumbers: [1,2,3,4,5,6],
            selectedTimes: dp.selectedTimes,
            isAutoGeneratedTimes: dp.isAutoGeneratedTimes,
            selectedWeekdays: dp.selectedWeekdays,
            weeklyTimes: dp.weeklyTimes,
            weeklyAutoGenerated: dp.weeklyAutoGenerated,
            onDosageUnitChanged: (v) => setState(() => dp._dosageUnit = v!),
            onFrequencyTypeChanged: (v) => setState(() => dp._frequencyType = v!),
            onFrequencyNumberChanged: (v) => setState(() => dp._frequencyNumber = v!),
            onSelectTime: (i) async {
              final t = await showTimePicker(context: context, initialTime: TimeOfDay.now());
              if (t!=null) setState(() => dp._selectedTimes[i] = t);
            },
            onWeekdaySelected: (d,s) => setState(() {
              if (s) dp._selectedWeekdays.add(d); else dp._selectedWeekdays.remove(d);
            }),
            onSelectWeeklyTime: (d) async {
              final t = await showTimePicker(context: context, initialTime: TimeOfDay.now());
              if (t!=null) setState(() => dp._weeklyTimes[d] = t);
            },
            onApplySameTimeToAllWeekdays: () => setState(() {
              final days = dp._selectedWeekdays.toList()..sort();
              final base = dp._weeklyTimes[days.first];
              for (var d in days.skip(1)) dp._weeklyTimes[d] = base;
            }),
            onNext: () => dp.pageController.nextPage(
              duration: const Duration(milliseconds: 500),
              curve: Curves.easeInOutCubic,
            ),
            onBack: () => dp.pageController.previousPage(
              duration: const Duration(milliseconds: 500),
              curve: Curves.easeInOutCubic,
            ),
            getDayName: (d) => ['','الإثنين','الثلاثاء','الأربعاء','الخميس','الجمعة','السبت','الأحد'][d],
          ),

          AddStartEndDatePage(
            formKey: GlobalKey<FormState>(),
            startDate: dp.startDate,
            endDate: dp.endDate,
            onSelectStartDate: () async {
              final d = await showDatePicker(
                context: context,
                initialDate: dp.startDate ?? DateTime.now(),
                firstDate: DateTime(2000),
                lastDate: DateTime.now().add(const Duration(days:3650)),
              );
              if (d != null) setState(() => dp.updateStartDate(d));
            },
            onSelectEndDate: () async {
              final d = await showDatePicker(
                context: context,
                initialDate: dp.endDate ?? dp.startDate ?? DateTime.now(),
                firstDate: dp.startDate ?? DateTime.now(),
                lastDate: DateTime.now().add(const Duration(days:3650)),
              );
              if (d != null) setState(() => dp.updateEndDate(d));
            },
            onClearEndDate: () => setState(() => dp.updateEndDate(null)),
            onSubmit: () async {
              await dp.updateMedication(widget.docId);
              if (mounted) Navigator.pop(context, true);
            },
            onBack: () => dp.pageController.previousPage(
              duration: const Duration(milliseconds: 500),
              curve: Curves.easeInOutCubic,
            ),
          ),
        ],
      ),
    );
  }
}



/// Helper utilities: time parsing, date calc, permissions, ImgBB upload.
class EditMedicationUtils {
  static TimeOfDay? parseTime(String timeStr) {
    try {
      final f = DateFormat('h:mm a', 'en_US');
      return TimeOfDay.fromDateTime(f.parseStrict(timeStr));
    } catch (_) {}
    return null;
  }

  static String formatTimeOfDay(TimeOfDay t) {
    final dt = DateTime(0, 0, 0, t.hour, t.minute);
    return DateFormat.jm('ar').format(dt);
  }

  static int calculateDays(DateTime start, DateTime end) => end.difference(start).inDays + 1;

  static Future<void> ensureCameraPermission() async {
    final st = await Permission.camera.request();
    if (!st.isGranted) {
      if (st.isPermanentlyDenied) openAppSettings();
      throw Exception('Camera permission denied');
    }
  }

  static Future<String> uploadToImgBB(File file, String apiKey) async {
    final b64 = base64Encode(await file.readAsBytes());
    final uri = Uri.parse('https://api.imgbb.com/1/upload?key=$apiKey');
    final resp = await http.post(uri, body: {'image': b64});
    if (resp.statusCode != 200) throw Exception('ImgBB upload failed');
    final data = json.decode(resp.body)['data'];
    return data['url'] as String;
  }
}

