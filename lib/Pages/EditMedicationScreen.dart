import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:image_picker/image_picker.dart';
import 'package:http/http.dart' as http;
import 'package:mudhkir_app/Pages/Add_Medicaiton/Add_Dosage.dart';
import 'package:mudhkir_app/Pages/Add_Medicaiton/Add_Name_Picture.dart';
import 'package:mudhkir_app/Pages/Add_Medicaiton/Add_Start_&_End_Date.dart';

import 'package:permission_handler/permission_handler.dart';
import 'package:mudhkir_app/main.dart'; // Import the notification utility

// Import the screens if you're reusing components
import '../services/AlarmNotificationHelper.dart';
import 'add_dose.dart'; // Import TimeUtils

// Constants for theming
const Color kPrimaryColor = Color(0xFF1A5CFF); // Primary blue
const Color kSecondaryColor = Color(0xFF4ECDC4); // Teal accent
const Color kErrorColor = Color(0xFFFF6B6B); // Error red
const Color kBackgroundColor = Color(0xFFF7F9FC); // Light background
const Color kCardColor = Colors.white;
const double kBorderRadius = 16.0;
const double kSpacing = 18.0;

class EditMedicationScreen extends StatefulWidget {
  final String docId;

  const EditMedicationScreen({
    Key? key,
    required this.docId,
  }) : super(key: key);

  @override
  _EditMedicationScreenState createState() => _EditMedicationScreenState();
}

class _EditMedicationScreenState extends State<EditMedicationScreen> {
  final String imgbbApiKey = '2b30d3479663bc30a70c916363b07c4a';

  final PageController _pageController = PageController();
  final GlobalKey<FormState> _formKeyPage1 = GlobalKey<FormState>();
  final GlobalKey<FormState> _formKeyPage2 = GlobalKey<FormState>();
  final GlobalKey<FormState> _formKeyPage3 = GlobalKey<FormState>();

  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _dosageController = TextEditingController();
  String _dosageUnit = 'ملغم';
  List<TimeOfDay?> _selectedTimes = [];
  List<bool> _isAutoGeneratedTimes = [];
  String _frequencyType = 'يومي';
  int _frequencyNumber = 1;
  DateTime? _startDate;
  DateTime? _endDate;
  late Future<List<String>> _medicineNamesFuture;

  File? _capturedImage;
  String? _uploadedImageUrl;
  bool _isUploading = false;
  bool _isLoading = true;
  bool _hasOriginalImage = false;

  final List<String> _dosageUnits = ['ملغم', 'غرام', 'مل', 'وحدة'];
  final List<String> _frequencyTypes = ['يومي', 'اسبوعي'];
  final List<int> _frequencyNumbers = [1, 2, 3, 4, 5, 6];

  Map<int, TimeOfDay?> _weeklyTimes = {};
  Map<int, bool> _weeklyAutoGenerated = {};
  Set<int> _selectedWeekdays = {};
  List<int> _originalNotificationIds = [];

  @override
  void initState() {
    super.initState();
    _medicineNamesFuture = _loadMedicineNames();
    _loadMedicationData();
  }

  @override
  void dispose() {
    _nameController.dispose();
    _dosageController.dispose();
    _pageController.dispose();
    super.dispose();
  }

  Future<List<String>> _loadMedicineNames() async {
    try {
      final String jsonString = await rootBundle.loadString('assets/Mediciens/trade_names.json');
      final List<dynamic> jsonList = json.decode(jsonString);
      return jsonList.map((item) => item.toString()).toList();
    } catch (e) {
      print('Error loading medicine names: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('حدث خطأ أثناء تحميل قائمة الأدوية')),
        );
      }
      return [];
    }
  }

  Future<void> _loadMedicationData() async {
    setState(() => _isLoading = true);
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) {
        _showBlockingAlert("خطأ", "المستخدم غير مسجل الدخول.");
        Navigator.pop(context);
        return;
      }
      final medicineDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .collection('medicines')
          .doc(widget.docId)
          .get();
      if (!medicineDoc.exists || !mounted) {
        _showBlockingAlert("خطأ", "لم يتم العثور على بيانات الدواء.");
        Navigator.pop(context);
        return;
      }
      final medicineData = medicineDoc.data()!;
      _nameController.text = medicineData['name'] ?? '';
      final String? dosageStr = medicineData['dosage'];
      if (dosageStr != null) {
        final dosageParts = dosageStr.split(' ');
        if (dosageParts.length >= 2) {
          _dosageController.text = dosageParts[0];
          final unit = dosageParts.sublist(1).join(' ');
          if (_dosageUnits.contains(unit)) {
            _dosageUnit = unit;
          }
        }
      }
      _frequencyType = medicineData['frequencyType'] ?? 'يومي';
      if (_frequencyType == 'يومي') {
        final frequencyDetails = medicineData['frequencyDetails'];
        if (frequencyDetails != null && frequencyDetails is Map<String, dynamic>) {
          _frequencyNumber = frequencyDetails['timesPerDay'] ?? 1;
        }
        final List<dynamic>? timesList = medicineData['times'];
        if (timesList != null) {
          _selectedTimes = List.filled(_frequencyNumber, null, growable: true);
          _isAutoGeneratedTimes = List.filled(_frequencyNumber, false, growable: true);
          for (int i = 0; i < timesList.length && i < _frequencyNumber; i++) {
            final String timeStr = timesList[i] ?? '';
            _selectedTimes[i] = TimeUtils.parseTime(timeStr);
          }
        }
      } else {
        final frequencyDetails = medicineData['frequencyDetails'];
        if (frequencyDetails != null && frequencyDetails is Map<String, dynamic>) {
          final List<dynamic>? weekdaysList = frequencyDetails['selectedWeekdays'];
          if (weekdaysList != null) {
            _selectedWeekdays = Set<int>.from(weekdaysList);
            final List<dynamic>? timesList = medicineData['times'];
            if (timesList != null) {
              for (final timeData in timesList) {
                if (timeData is Map<String, dynamic>) {
                  final int day = timeData['day'] ?? 0;
                  final String timeStr = timeData['time'] ?? '';
                  if (day != 0 && timeStr.isNotEmpty) {
                    _weeklyTimes[day] = TimeUtils.parseTime(timeStr);
                    _weeklyAutoGenerated[day] = false;
                  }
                }
              }
            }
          }
        }
      }
      final startDateTimestamp = medicineData['startDate'];
      if (startDateTimestamp != null && startDateTimestamp is Timestamp) {
        _startDate = startDateTimestamp.toDate();
      } else {
        _startDate = DateTime.now();
      }
      final endDateTimestamp = medicineData['endDate'];
      if (endDateTimestamp != null && endDateTimestamp is Timestamp) {
        _endDate = endDateTimestamp.toDate();
      }
      final String? imageUrl = medicineData['imageUrl'];
      if (imageUrl != null && imageUrl.isNotEmpty) {
        _uploadedImageUrl = imageUrl;
        _hasOriginalImage = true;
      }
      final List<dynamic>? notificationIds = medicineData['notificationIds'];
      if (notificationIds != null) {
        _originalNotificationIds = List<int>.from(notificationIds);
      }
      setState(() => _isLoading = false);
    } catch (e) {
      print("Error loading medication data: $e");
      if (mounted) {
        setState(() => _isLoading = false);
        _showBlockingAlert("خطأ", "حدث خطأ أثناء تحميل بيانات الدواء: $e");
      }
    }
  }

  void _updateTimeFields() {
    setState(() {
      List<TimeOfDay?> oldTimes = List.from(_selectedTimes);
      List<bool> oldAutoGenerated = List.from(_isAutoGeneratedTimes);
      _selectedTimes = List.generate(
          _frequencyNumber,
              (index) => index < oldTimes.length ? oldTimes[index] : null,
          growable: true
      );
      _isAutoGeneratedTimes = List.generate(
          _frequencyNumber,
              (index) => index < oldAutoGenerated.length ? oldAutoGenerated[index] : false,
          growable: true
      );
      if (_frequencyType == 'يومي' && _selectedTimes.isNotEmpty && _selectedTimes[0] != null) {
        _autoFillDosageTimes();
      }
    });
  }

  void _autoFillDosageTimes() {
    if (_frequencyType != 'يومي' || _selectedTimes.isEmpty || _selectedTimes[0] == null || _frequencyNumber <= 1) {
      return;
    }
    final firstDose = _selectedTimes[0]!;
    DateTime base = DateTime(2000, 1, 1, firstDose.hour, firstDose.minute);
    int intervalMinutes = (24 * 60 / _frequencyNumber).round();
    List<TimeOfDay?> newTimes = List.from(_selectedTimes);
    List<bool> newAutoGenerated = List.from(_isAutoGeneratedTimes);
    bool changed = false;
    for (int i = 1; i < _frequencyNumber; i++) {
      if (newTimes[i] == null || newAutoGenerated[i]) {
        DateTime newTime = base.add(Duration(minutes: intervalMinutes * i));
        TimeOfDay newTimeOfDay = TimeOfDay(hour: newTime.hour, minute: newTime.minute);
        if (newTimes[i] != newTimeOfDay || !newAutoGenerated[i]) {
          newTimes[i] = newTimeOfDay;
          newAutoGenerated[i] = true;
          changed = true;
        }
      }
    }
    if (changed && mounted) {
      setState(() {
        _selectedTimes = newTimes;
        _isAutoGeneratedTimes = newAutoGenerated;
      });
    }
  }

  void _initializeWeeklySchedule() {
    setState(() {
      Map<int, TimeOfDay?> updatedWeeklyTimes = {};
      Map<int, bool> updatedWeeklyAutoGenerated = {};
      for (int day in _selectedWeekdays) {
        updatedWeeklyTimes[day] = _weeklyTimes[day];
        updatedWeeklyAutoGenerated[day] = _weeklyAutoGenerated[day] ?? false;
      }
      _weeklyTimes = updatedWeeklyTimes;
      _weeklyAutoGenerated = updatedWeeklyAutoGenerated;
    });
  }

  Future<void> _selectStartDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _startDate ?? DateTime.now(),
      firstDate: DateTime(2000),
      lastDate: DateTime(DateTime.now().year + 10),
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: ColorScheme.light(
              primary: kPrimaryColor,
              secondary: kSecondaryColor,
            ),
          ),
          child: child!,
        );
      },
    );
    if (picked != null && picked != _startDate && mounted) {
      setState(() {
        _startDate = picked;
        if (_endDate != null && _endDate!.isBefore(picked)) {
          _endDate = null;
        }
      });
    }
  }

  Future<void> _selectEndDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _endDate ?? _startDate ?? DateTime.now(),
      firstDate: _startDate ?? DateTime.now().subtract(const Duration(days: 1)),
      lastDate: DateTime(DateTime.now().year + 10),
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: ColorScheme.light(
              primary: kPrimaryColor,
              secondary: kSecondaryColor,
            ),
          ),
          child: child!,
        );
      },
    );
    if (picked != null && picked != _endDate && mounted) {
      setState(() => _endDate = picked);
    }
  }

  Future<void> _selectTime(int index) async {
    final TimeOfDay initialTime = _selectedTimes.length > index && _selectedTimes[index] != null
        ? _selectedTimes[index]!
        : TimeOfDay.now();
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: initialTime,
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: ColorScheme.light(
              primary: kPrimaryColor,
              secondary: kSecondaryColor,
            ),
          ),
          child: child!,
        );
      },
    );
    if (picked != null && mounted) {
      setState(() {
        if (index < _selectedTimes.length) {
          _selectedTimes[index] = picked;
          _isAutoGeneratedTimes[index] = false;
          if (index == 0 && _frequencyType == 'يومي') _autoFillDosageTimes();
        }
      });
    }
  }

  Future<void> _selectWeeklyTime(int day) async {
    final TimeOfDay initialTime = _weeklyTimes[day] ?? TimeOfDay.now();
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: initialTime,
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: ColorScheme.light(
              primary: kPrimaryColor,
              secondary: kSecondaryColor,
            ),
          ),
          child: child!,
        );
      },
    );
    if (picked != null && mounted) {
      setState(() {
        _weeklyTimes[day] = picked;
        _weeklyAutoGenerated[day] = false;
      });
    }
  }

  void _handleWeekdaySelected(int day, bool isSelected) {
    setState(() {
      if (isSelected) {
        if (_selectedWeekdays.length < 6) {
          _selectedWeekdays.add(day);
          if (!_weeklyTimes.containsKey(day)) {
            _weeklyTimes[day] = null;
            _weeklyAutoGenerated[day] = false;
          }
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('يمكنك اختيار 6 أيام فقط كحد أقصى')),
          );
        }
      } else {
        _selectedWeekdays.remove(day);
        _weeklyTimes.remove(day);
        _weeklyAutoGenerated.remove(day);
      }
    });
  }

  void _handleApplySameTimeToAllWeekdays() {
    List<int> sortedDays = _selectedWeekdays.toList()..sort();
    if (sortedDays.isEmpty || _weeklyTimes[sortedDays.first] == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("الرجاء تحديد وقت لليوم الأول في القائمة أولاً")),
      );
      return;
    }
    final firstTime = _weeklyTimes[sortedDays.first]!;
    bool changed = false;
    setState(() {
      for (int day in sortedDays.skip(1)) {
        if (_weeklyTimes[day] == null || (_weeklyAutoGenerated[day] ?? false)) {
          if (_weeklyTimes[day] != firstTime || !(_weeklyAutoGenerated[day] ?? false)) {
            _weeklyTimes[day] = firstTime;
            _weeklyAutoGenerated[day] = true;
            changed = true;
          }
        }
      }
    });
    if (changed) {
      print("Applied same time to other weekdays.");
    }
  }

  Future<void> _pickImage() async {
    File? tempImage;
    bool wasUploading = _isUploading;
    try {
      var status = await Permission.camera.request();
      if (status.isGranted) {
        final pickedFile = await ImagePicker().pickImage(source: ImageSource.camera);
        if (pickedFile != null) {
          tempImage = File(pickedFile.path);
          if (mounted) {
            setState(() {
              _capturedImage = tempImage;
              _uploadedImageUrl = null;
              _hasOriginalImage = false;
              _isUploading = true;
            });
          }
          _uploadImageToImgBB(tempImage).then((url) {
            if (mounted) {
              setState(() {
                _uploadedImageUrl = url;
                _isUploading = false;
              });
            }
          }).catchError((e) {
            if (mounted) {
              setState(() => _isUploading = false);
              _showBlockingAlert("خطأ تحميل", "فشل تحميل الصورة. الرجاء المحاولة مرة أخرى.");
            }
          });
        } else {
          if (mounted && wasUploading) setState(() => _isUploading = false);
        }
      } else if (status.isPermanentlyDenied) {
        _showBlockingAlert(
            "الإذن مطلوب",
            "تم رفض الوصول إلى الكاميرا بشكل دائم. يرجى تمكين الإذن من إعدادات التطبيق.",
            onOk: openAppSettings
        );
        if (mounted && wasUploading) setState(() => _isUploading = false);
      } else {
        _showBlockingAlert("الإذن مطلوب", "يجب السماح بالوصول إلى الكاميرا لالتقاط صورة.");
        if (mounted && wasUploading) setState(() => _isUploading = false);
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isUploading = false);
        _showBlockingAlert("خطأ", "حدث خطأ أثناء التقاط الصورة.");
      }
    }
  }

  Future<String?> _uploadImageToImgBB(File imageFile) async {
    try {
      final bytes = await imageFile.readAsBytes();
      final base64Image = base64Encode(bytes);
      final url = Uri.parse('https://api.imgbb.com/1/upload?key=$imgbbApiKey');
      final response = await http.post(url, body: {'image': base64Image})
          .timeout(const Duration(seconds: 60));
      if (response.statusCode == 200) {
        final jsonResponse = json.decode(response.body);
        final imageUrl = jsonResponse['data']?['url'] as String?;
        return imageUrl;
      } else {
        throw Exception("فشل تحميل الصورة. رمز الحالة: ${response.statusCode}");
      }
    } on TimeoutException {
      throw Exception("فشل تحميل الصورة: انتهت مهلة الطلب.");
    } catch (e) {
      throw Exception("حدث خطأ غير متوقع أثناء تحميل الصورة: $e");
    }
  }

  void _nextPage() {
    if (!_pageController.hasClients) return;
    _pageController.nextPage(
      duration: const Duration(milliseconds: 500), // updated duration
      curve: Curves.easeInOutCubic,               // updated curve
    );
  }

  void _previousPage() {
    if (!_pageController.hasClients) return;
    _pageController.previousPage(
      duration: const Duration(milliseconds: 500), // updated duration
      curve: Curves.easeInOutCubic,                // updated curve
    );
  }

  Future<void> _updateMedication() async {
    if (!_formKeyPage3.currentState!.validate()) return;
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      _showBlockingAlert("خطأ", "المستخدم غير مسجل الدخول.");
      return;
    }
    if (_capturedImage != null && _isUploading) {
      _showBlockingAlert("انتظار", "يتم تحميل الصورة حالياً. الرجاء الانتظار لحظات ثم المحاولة مرة أخرى.");
      return;
    }
    if (_frequencyType == 'اسبوعي') {
      if (_selectedWeekdays.isEmpty) {
        _showBlockingAlert("خطأ", "الرجاء تحديد يوم واحد على الأقل للجدول الأسبوعي.");
        return;
      }
      bool allWeeklyTimesSet = _selectedWeekdays.every((day) => _weeklyTimes[day] != null);
      if (!allWeeklyTimesSet) {
        _showBlockingAlert("خطأ", "الرجاء تحديد وقت لكل يوم تم اختياره في الجدول الأسبوعي.");
        return;
      }
    }
    List<String> dailyTimesFormatted = [];
    List<Map<String, dynamic>> weeklyScheduleFormatted = [];
    List<Map<String, dynamic>> missedDoses = [];
    if (_frequencyType == 'يومي') {
      dailyTimesFormatted = _selectedTimes
          .where((t) => t != null)
          .map((t) => TimeUtils.formatTimeOfDay(context, t!))
          .toList();
      if (_startDate != null) {
        for (var time in _selectedTimes) {
          if (time != null) {
            DateTime doseDateTime = DateTime(
                _startDate!.year, _startDate!.month, _startDate!.day,
                time.hour, time.minute
            );
            missedDoses.add({
              'scheduled': Timestamp.fromDate(doseDateTime),
              'status': 'pending'
            });
          }
        }
      }
    } else {
      List<int> sortedDays = _selectedWeekdays.toList()..sort();
      weeklyScheduleFormatted = sortedDays.map((day) {
        final time = _weeklyTimes[day];
        return {
          'day': day,
          'time': time != null ? TimeUtils.formatTimeOfDay(context, time) : ''
        };
      }).toList();
      if (_startDate != null) {
        DateTime currentCheckDate = _startDate!;
        DateTime firstWeekEndDate = _startDate!.add(const Duration(days: 7));
        DateTime effectiveEndDate = _endDate != null && _endDate!.isBefore(firstWeekEndDate)
            ? _endDate!.add(const Duration(days: 1))
            : firstWeekEndDate;
        while(currentCheckDate.isBefore(effectiveEndDate)) {
          if (_selectedWeekdays.contains(currentCheckDate.weekday)) {
            final time = _weeklyTimes[currentCheckDate.weekday];
            if (time != null) {
              DateTime doseDateTime = DateTime(
                  currentCheckDate.year, currentCheckDate.month, currentCheckDate.day,
                  time.hour, time.minute
              );
              missedDoses.add({
                'scheduled': Timestamp.fromDate(doseDateTime),
                'status': 'pending'
              });
            }
          }
          currentCheckDate = currentCheckDate.add(const Duration(days: 1));
        }
      }
    }
    final updatedMedicine = <String, dynamic>{
      'name': _nameController.text.trim(),
      'dosage': '${_dosageController.text.trim()} $_dosageUnit',
      'frequencyType': _frequencyType,
      'frequencyDetails': _frequencyType == 'يومي'
          ? {'timesPerDay': _frequencyNumber}
          : {'selectedWeekdays': _selectedWeekdays.toList()..sort()},
      'times': _frequencyType == 'يومي' ? dailyTimesFormatted : weeklyScheduleFormatted,
      'startDate': _startDate != null ? Timestamp.fromDate(_startDate!) : null,
      'endDate': _endDate != null ? Timestamp.fromDate(_endDate!) : null,
      'missedDoses': missedDoses,
      'lastUpdated': Timestamp.now(),
    };
    if (_uploadedImageUrl != null && _uploadedImageUrl!.isNotEmpty) {
      updatedMedicine['imageUrl'] = _uploadedImageUrl;
    } else if (_hasOriginalImage) {
      // Keep original image
    } else {
      updatedMedicine['imageUrl'] = null;
    }

    try {
      await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .collection('medicines')
          .doc(widget.docId)
          .update(updatedMedicine);
      if (_originalNotificationIds.isNotEmpty) {
        for (int id in _originalNotificationIds) {
          await AlarmNotificationHelper.cancelNotification(id);
        }
      }
      List<int> newNotificationIds = [];
      int baseNotificationId = widget.docId.hashCode.abs() % 2147483647;
      int notificationCounter = 0;
      if (_frequencyType == 'يومي') {
        for (var time in _selectedTimes) {
          if (time != null) {
            // Build the first dose DateTime using _startDate and the selected time.
            DateTime firstDoseTime = DateTime(
              _startDate!.year,
              _startDate!.month,
              _startDate!.day,
              time.hour,
              time.minute,
            );
            // If the computed first dose time is already past, shift it to tomorrow.
            if (firstDoseTime.isBefore(DateTime.now())) {
              firstDoseTime = firstDoseTime.add(const Duration(days: 1));
            }
            final notificationId = baseNotificationId + notificationCounter++;
            newNotificationIds.add(notificationId);
            await AlarmNotificationHelper.scheduleDailyRepeatingNotification(
              id: notificationId,
              title: 'تذكير الدواء',
              body: 'حان وقت تناول ${_nameController.text.trim()}',
              timeOfDay: time,
              payload: widget.docId,
              startDate: firstDoseTime, // Use adjusted firstDoseTime
              endDate: _endDate,
            );
          }
        }
      } else {
        for (int day in _selectedWeekdays) {
          final time = _weeklyTimes[day];
          if (time != null) {
            final notificationId = baseNotificationId + notificationCounter++;
            newNotificationIds.add(notificationId);
            await AlarmNotificationHelper.scheduleWeeklyRepeatingNotification(
              id: notificationId,
              title: 'تذكير الدواء',
              body: 'حان وقت تناول ${_nameController.text.trim()}',
              weekday: day,
              timeOfDay: time,
              payload: widget.docId,
              startDate: _startDate ?? DateTime.now(),
              endDate: _endDate,
            );
          }
        }
      }

      if (newNotificationIds.isNotEmpty) {
        await FirebaseFirestore.instance
            .collection('users')
            .doc(user.uid)
            .collection('medicines')
            .doc(widget.docId)
            .update({'notificationIds': newNotificationIds});
      }
      if (mounted) {
        _showBlockingAlert("نجاح", "تم تحديث الدواء وجدولة التذكيرات بنجاح!", onOk: () {
          if (mounted) Navigator.pop(context, true);
        });
      }
    } catch (e, s) {
      print("❌ Firestore update error: $e");
      print("❌ Stack trace: $s");
      if (mounted) {
        _showBlockingAlert("خطأ", "حدث خطأ أثناء تحديث بيانات الدواء: $e");
      }
    }
  }

  void _showBlockingAlert(String title, String message, {VoidCallback? onOk}) {
    if (!mounted) return;
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return AlertDialog(
          backgroundColor: kCardColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(kBorderRadius),
          ),
          title: Text(title,
              textAlign: TextAlign.center,
              style: TextStyle(
                  color: kPrimaryColor,
                  fontWeight: FontWeight.bold
              )
          ),
          content: Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0),
            child: Text(message,
                textAlign: TextAlign.center,
                style: const TextStyle(fontSize: 16)
            ),
          ),
          actionsAlignment: MainAxisAlignment.center,
          actions: [
            TextButton(
              child: const Text("حسناً",
                  style: TextStyle(
                      fontWeight: FontWeight.bold
                  )
              ),
              onPressed: () {
                Navigator.of(context).pop();
                onOk?.call();
              },
            )
          ],
        );
      },
    );
  }

  String _dayName(int day) {
    switch (day) {
      case 1: return "الإثنين";
      case 2: return "الثلاثاء";
      case 3: return "الأربعاء";
      case 4: return "الخميس";
      case 5: return "الجمعة";
      case 6: return "السبت";
      case 7: return "الأحد";
      default: return "";
    }
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () => FocusScope.of(context).unfocus(),
      child: Scaffold(
        backgroundColor: kBackgroundColor,
        appBar: AppBar(
          title: const Text(
            'تعديل الدواء',
            style: TextStyle(fontWeight: FontWeight.bold),
          ),
          centerTitle: true,
          backgroundColor: kPrimaryColor,
          foregroundColor: Colors.white,
          elevation: 1,
          shape: const RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(bottom: Radius.circular(18)),
          ),
          leading: IconButton(
            icon: const Icon(Icons.close),
            onPressed: () {
              showDialog(
                context: context,
                builder: (ctx) => AlertDialog(
                  backgroundColor: kCardColor,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(kBorderRadius),
                  ),
                  title: const Text("هل تريد إلغاء التعديل؟", textAlign: TextAlign.center),
                  content: const Text("سيتم تجاهل جميع التغييرات التي قمت بها.", textAlign: TextAlign.center),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.of(ctx).pop(),
                      child: const Text("متابعة التحرير"),
                    ),
                    ElevatedButton(
                      onPressed: () {
                        Navigator.of(ctx).pop();
                        Navigator.of(context).pop();
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: kErrorColor,
                      ),
                      child: const Text("نعم، إلغاء"),
                    ),
                  ],
                ),
              );
            },
          ),
        ),
        body: _isLoading
            ? Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const CircularProgressIndicator(color: kPrimaryColor),
              const SizedBox(height: 20),
              Text(
                "جاري تحميل بيانات الدواء...",
                style: TextStyle(
                  fontSize: 16,
                  color: Colors.grey.shade700,
                ),
              ),
            ],
          ),
        )
            : Stack(
          children: [
            AnimatedContainer(
              duration: const Duration(milliseconds: 400),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [kPrimaryColor.withOpacity(0.10), kBackgroundColor, Colors.white],
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  stops: const [0, 0.3, 1],
                ),
              ),
            ),

            // Page indicator with edit mode indicator
            Positioned(
              top: 0,
              left: 0,
              right: 0,
              child: AnimatedBuilder(
                animation: _pageController,
                builder: (context, _) {
                  final currentPage = _pageController.hasClients
                      ? _pageController.page?.round() ?? 0
                      : 0;
                  return Column(
                    children: [
                      // Page indicator dots
                      Container(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        color: Colors.transparent,
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [0, 1, 2].map((index) => Container(
                            width: 30,
                            height: 4,
                            margin: const EdgeInsets.symmetric(horizontal: 4),
                            decoration: BoxDecoration(
                              borderRadius: BorderRadius.circular(10),
                              color: currentPage == index
                                  ? kPrimaryColor
                                  : kPrimaryColor.withOpacity(0.3),
                            ),
                          )).toList(),
                        ),
                      ),
                    ],
                  );
                },
              ),
            ),

            // PageView with added top padding for each page
            PageView(
              controller: _pageController,
              physics: const NeverScrollableScrollPhysics(),
              children: [
                Padding(
                  padding: const EdgeInsets.only(top: 60.0),
                  child: AddNamePicturePage(
                    formKey: _formKeyPage1,
                    nameController: _nameController,
                    medicineNamesFuture: _medicineNamesFuture,
                    capturedImage: _capturedImage,
                    uploadedImageUrl: _hasOriginalImage ? _uploadedImageUrl : null,
                    onPickImage: _pickImage,
                    onNext: () {
                      if (_formKeyPage1.currentState!.validate()) {
                        if (_capturedImage != null && _isUploading) {
                          _showBlockingAlert("انتظار", "يتم تحميل الصورة حالياً. الرجاء الانتظار.");
                        } else {
                          _nextPage();
                        }
                      }
                    },
                    onBack: () {
                      showDialog(
                        context: context,
                        builder: (ctx) => AlertDialog(
                          backgroundColor: kCardColor,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(kBorderRadius),
                          ),
                          title: const Text("هل تريد إلغاء التعديل؟", textAlign: TextAlign.center),
                          content: const Text("سيتم تجاهل جميع التغييرات التي قمت بها.", textAlign: TextAlign.center),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.of(ctx).pop(),
                              child: const Text("متابعة التحرير"),
                            ),
                            ElevatedButton(
                              onPressed: () {
                                Navigator.of(ctx).pop();
                                Navigator.of(context).pop();
                              },
                              style: ElevatedButton.styleFrom(
                                backgroundColor: kErrorColor,
                              ),
                              child: const Text("نعم، إلغاء"),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                ),

                Padding(
                  padding: const EdgeInsets.only(top: 60.0),
                  child: AddDosagePage(
                    formKey: _formKeyPage2,
                    dosageController: _dosageController,
                    dosageUnit: _dosageUnit,
                    dosageUnits: _dosageUnits,
                    frequencyType: _frequencyType,
                    frequencyTypes: _frequencyTypes,
                    frequencyNumber: _frequencyNumber,
                    frequencyNumbers: _frequencyNumbers,
                    selectedTimes: _selectedTimes,
                    isAutoGeneratedTimes: _isAutoGeneratedTimes,
                    selectedWeekdays: _selectedWeekdays,
                    weeklyTimes: _weeklyTimes,
                    weeklyAutoGenerated: _weeklyAutoGenerated,
                    onDosageUnitChanged: (value) {
                      if (value != null && mounted) setState(() => _dosageUnit = value);
                    },
                    onFrequencyNumberChanged: (value) {
                      if (value != null && value != _frequencyNumber && mounted) {
                        setState(() => _frequencyNumber = value);
                        _updateTimeFields();
                      }
                    },
                    onFrequencyTypeChanged: (value) {
                      if (value != null && value != _frequencyType && mounted) {
                        setState(() {
                          _frequencyType = value;
                          if (value == 'يومي') {
                            _updateTimeFields();
                            _selectedWeekdays.clear();
                            _weeklyTimes.clear();
                            _weeklyAutoGenerated.clear();
                          } else {
                            _selectedTimes = List.filled(_frequencyNumber, null, growable: true);
                            _isAutoGeneratedTimes = List.filled(_frequencyNumber, false, growable: true);
                            _initializeWeeklySchedule();
                          }
                        });
                      }
                    },
                    onSelectTime: _selectTime,
                    onWeekdaySelected: _handleWeekdaySelected,
                    onSelectWeeklyTime: _selectWeeklyTime,
                    onApplySameTimeToAllWeekdays: _handleApplySameTimeToAllWeekdays,
                    onNext: () {
                      if (_formKeyPage2.currentState!.validate()) {
                        bool allTimesFilled = _frequencyType == 'يومي'
                            ? _selectedTimes.every((t) => t != null)
                            : (_selectedWeekdays.isEmpty || _selectedWeekdays.every((day) => _weeklyTimes[day] != null));
                        if (allTimesFilled) {
                          _nextPage();
                        } else {
                          ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(content: Text('الرجاء تحديد جميع أوقات الجرعات المطلوبة.'))
                          );
                        }
                      }
                    },
                    onBack: _previousPage,
                    getDayName: _dayName,
                  ),
                ),

                Padding(
                  padding: const EdgeInsets.only(top: 60.0),
                  child: AddStartEndDatePage(
                    formKey: _formKeyPage3,
                    startDate: _startDate,
                    endDate: _endDate,
                    onSelectStartDate: _selectStartDate,
                    onSelectEndDate: _selectEndDate,
                    onSubmit: _updateMedication,
                    onBack: _previousPage,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

